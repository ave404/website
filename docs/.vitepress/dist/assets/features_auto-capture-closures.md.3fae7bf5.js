import{_ as s,c as a,o as n,a as e}from"./app.e13f5bad.js";const A=JSON.parse('{"title":"Auto-capture Closures","description":"","frontmatter":{},"headers":[{"level":2,"title":"Capturing by-value or by-reference","slug":"capturing-by-value-or-by-reference","link":"#capturing-by-value-or-by-reference","children":[]}],"relativePath":"features/auto-capture-closures.md","lastUpdated":1677607338000}'),l={name:"features/auto-capture-closures.md"},o=e(`<h1 id="auto-capture-closures" tabindex="-1">Auto-capture Closures <a class="header-anchor" href="#auto-capture-closures" aria-hidden="true">#</a></h1><p>Since the introduction of arrow functions <code>fn () =&gt; ...</code> in PHP 7.4, many PHP developers have been looking for a solution to multi-line auto-capturing closures. The current solution to using out-of-scope variables inside of a closure involves specifying each variable inside of the function&#39;s <code>use</code> clause.</p><div class="language-php line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">wrap</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">Closure</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">callback</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...$</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Closure</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">use</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">($</span><span style="color:#A6ACCD;">callback</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">callback</span><span style="color:#89DDFF;">(...$</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>An attempt to introduce auto-capturing closures was attempted in May 2022 (<a href="https://wiki.php.net/rfc/auto-capture-closure" target="_blank" rel="noreferrer">RFC</a>) but the vote was just shy of the 2/3 majority required to pass.</p><p>PXP follows this proposal very closely with its implementation of auto-capturing closures. Converting the <code>wrap()</code> function above would look something like below:</p><div class="language-pxp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">pxp</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">wrap</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">Closure</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">callback</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...$</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Closure</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">fn</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> {</span></span>
<span class="line"><span style="color:#A6ACCD;">        return $callback</span><span style="color:#89DDFF;">(...$</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    };</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The <code>use</code> clause can be completely removed as PXP will handle the capturing automatically during transpilation.</p><h2 id="capturing-by-value-or-by-reference" tabindex="-1">Capturing by-value or by-reference <a class="header-anchor" href="#capturing-by-value-or-by-reference" aria-hidden="true">#</a></h2><p>As described by the <a href="https://wiki.php.net/rfc/auto-capture-closure" target="_blank" rel="noreferrer">RFC</a>, the surrounding environment is captured by-value. This means that trying to update the value of a variable will only affect the variable inside of the closure&#39;s own scope and not the surrounding scope.</p><p>The only exception to this rule is updating / interacting with a variable that holds an object, since the underlying value is still a reference to an object in memory. This behavour is consistent with arrow functions.</p>`,10),p=[o];function r(t,c,i,u,y,C){return n(),a("div",null,p)}const d=s(l,[["render",r]]);export{A as __pageData,d as default};
